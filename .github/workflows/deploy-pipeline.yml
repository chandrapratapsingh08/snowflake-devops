name: Deploy data pipeline

# Action will run on pushes to selected branches
on:
  push:
    branches:
      - main

permissions:
  id-token: write
  contents: read
  deployments: write

jobs:
  deploy:
    runs-on: ubuntu-22.04
    
    env:
      SNOWFLAKE_ACCOUNT: ${{ vars.SNOWFLAKE_ACCOUNT }}
      REPO_NAME: snowflake_devops
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
    
      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: "3.9"
    
      - name: Install dependencies
        run: |
          pip install pyjwt cryptography

      - name: Install Dependencies
        run: pip install jinja2-cli

      - name: Decode private key
        id: decode-private-key
        run: |
          # Decode the Base64-encoded private key
          echo "${{ secrets.SNOWFLAKE_PRIVATE_KEY_BASE64 }}" | base64 --decode > rsa_key.p8

      - name: Generate Snowflake config.toml
        run: |
          mkdir -p .snowflake
          cat <<EOF > .snowflake/config.toml      
          [connections]
          [connections.workflow]
          account = "${{ vars.SNOWFLAKE_ACCOUNT }}"
          user = "${{ vars.SNOWFLAKE_DEVOPS_USER }}"
          role = "ACCOUNTADMIN"
          authenticator = "${{ vars.SNOWFLAKE_DEFAULT_AUTHENTICATOR }}"
          warehouse = "${{ vars.SNOWFLAKE_DEVOPS_WAREHOUSE }}"
          database = "${{ vars.SNOWFLAKE_DEVOPS_DB }}"
          schema = "${{ vars.SNOWFLAKE_DEVOPS_SCHEMA }}"
          private_key_file = "rsa_key.p8"
          EOF

      - name: Updated Permission for config.toml
        run: |
          chmod 0600 .snowflake/config.toml
          chown $USER .snowflake/config.toml

      - name: Install Snowflake CLI
        uses: Snowflake-Labs/snowflake-cli-action@v1.5
        with:
          cli-version: "latest"
          default-config-file-path: ".snowflake/config.toml"
    
      - name: Decode private key and generate JWT
        id: generate-jwt
        run: |  
          # Generate the JWT using the decoded private key and password
          from datetime import timedelta, timezone, datetime

          # This example relies on the PyJWT module (https://pypi.org/project/PyJWT/).
          import jwt

          # Construct the fully qualified name of the user in uppercase.
          # - Replace <account_identifier> with your account identifier.
          #   (See https://docs.snowflake.com/en/user-guide/admin-account-identifier.html .)
          # - Replace <user_name> with your Snowflake user name.
          account = ${{ vars.SNOWFLAKE_ACCOUNT }}

          # Get the account identifier without the region, cloud provider, or subdomain.
          if not '.global' in account:
              idx = account.find('.')
              if idx > 0:
                  account = account[0:idx]
              else:
                  # Handle the replication case.
                  idx = account.find('-')
                  if idx > 0:
                      account = account[0:idx]

          # Use uppercase for the account identifier and user name.
          account = account.upper()
          user = ${{ vars.SNOWFLAKE_DEVOPS_USER }}.upper()
          qualified_username = account + "." + user

          # Get the current time in order to specify the time when the JWT was issued and the expiration time of the JWT.
          now = datetime.now(timezone.utc)

          # Specify the length of time during which the JWT will be valid. You can specify at most 1 hour.
          lifetime = timedelta(minutes=59)

          # Create the payload for the token.
          payload = {

              # Set the issuer to the fully qualified username concatenated with the public key fingerprint (calculated in the  previous step).
              "iss": qualified_username + '.' + public_key_fp,

              # Set the subject to the fully qualified username.
              "sub": qualified_username,

              # Set the issue time to now.
              "iat": now,

              # Set the expiration time, based on the lifetime specified for this object.
              "exp": now + lifetime
          }

          # Generate the JWT. private_key is the private key that you read from the private key file in the previous step when you generated the public key fingerprint.
          encoding_algorithm="RS256"
          token = jwt.encode(payload, key=private_key, algorithm=encoding_algorithm)

          # If you are using a version of PyJWT prior to 2.0, jwt.encode returns a byte string, rather than a string.
          # If the token is a byte string, convert it to a string.
          if isinstance(token, bytes):
            token = token.decode('utf-8')
          decoded_token = jwt.decode(token, key=private_key.public_key(), algorithms=[encoding_algorithm])
          print("Generated a JWT with the following payload:\n{}".format(decoded_token))

      - name: Perform a Snowflake connectivity test
        env:
          SNOWFLAKE_CONNECTIONS_DEFAULT_JWT: ${{ steps.generate-jwt.outputs.jwt }}
          SNOWFLAKE_DEBUG: true  # Enable debugging
          PRIVATE_KEY_PASSPHRASE: ${{ secrets.SNOWFLAKE_PRIVATE_KEY_PASSWORD }}
        run: |
          snow connection list
          # Disable connection test as it relies upon databases and schemas
          # that might not be in place yet.
        # snow connection test -c workflow --debug

      - name: Fetch repository changes
        env:
          SNOWFLAKE_CONNECTIONS_DEFAULT_JWT: ${{ steps.generate-jwt.outputs.jwt }}
          SNOWFLAKE_DEBUG: true  # Enable debugging
          PRIVATE_KEY_PASSPHRASE: ${{ secrets.SNOWFLAKE_PRIVATE_KEY_PASSWORD }}
        run: snow git fetch snowflake_devops -c workflow --debug

      - name: Run Setup snowflake sql
        env:
          SNOWFLAKE_CONNECTIONS_DEFAULT_JWT: ${{ steps.generate-jwt.outputs.jwt }}
          SNOWFLAKE_DEBUG: true  # Enable debugging
          PRIVATE_KEY_PASSPHRASE: ${{ secrets.SNOWFLAKE_PRIVATE_KEY_PASSWORD }}
        run: |
          BRANCH_NAME="main"
          if [ "${BRANCH_NAME}" == "main" ]; then
            RETENTION_TIME=1
          else
            RETENTION_TIME=0
          fi
          snow git execute \
            "@${REPO_NAME}/branches/${BRANCH_NAME}/steps/0[134]_*" \
            -D "environment='${BRANCH_NAME}'" \
            -D "retention_time=${RETENTION_TIME}"